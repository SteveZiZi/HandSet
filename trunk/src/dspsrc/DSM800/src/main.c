/** ============================================================================
*  @file   main.c
*  @path   $(DSPLINK)/dsp/src/samples/loop/
*  @desc   Main function that calls SWI or TSK loopback applications based
*          on the compilation flag SWI_MODE or TSK_MODE.
*  @ver    1.64
*  ============================================================================*/
/*  ----------------------------------- DSP/BIOS Headers            */

#include <main.h>
#include <hal/hal_cache.h>
#include "DspArmProtocol.h"
#include "dspCalc.h"
#include "Clk.h"                                         // ÓÃÓÚÊ±¼ä¼ÆËã
#include "gbl.h"

#ifdef _DEBUG
#define FILEID FID_APP_C
#endif

#define _SMV_TIME_TEST  0								// ²âÊÔÐ³²¨¼ÆËãÊ±¼ä¿ª¹Ø
#define _DSP_VERSION 	7								// DSP°æ±¾ºÅ£¬Íâ²¿ÏÔÊ¾Îª³ýÒÔ10ºóµÄ¸¡µãÖµ
#define _LOST_POINT_MODE								// DSP¶ªµãÄ£Ê½£¬Èç¹û²»¶¨Òå¸Ãºê£¬ÔòÎª×èÈûÄ£Ê½

extern LOG_Obj trace;

Uint8 *g_recvBuf = NULL;                                 // Ö¸Ïò½ÓÊÕµ½Êý¾Ý»º´æÇø
Uint8 *g_sendBuf = NULL;                                 // Ö¸Ïò·¢ËÍÊý¾Ý»º´æÇø
Uint16 numTransfers ;
Uint32 xferBufSize ;

TSKLOOP_TransferInfo *info;                              // ½ÓÊÕ·¢ËÍÐÅÏ¢½á¹¹Ìå

Config g_config = {0};                                   ///< È«¾Ö²ÎÊýÉèÖÃ

SmvCalcData g_smvCalcData = {0};                         ///< È«¾Ö²ÉÑùÊý¾Ý»º´æ
SmvCalcData g_smvCalcData1 = {0};                        ///< È«¾Ö²ÉÑùÊý¾Ý»º´æ

MSGTIME g_msgTime[MAX_MSG_TIME_CALC_COUNT] = {0};        ///< È«¾Ö±¨ÎÄÊ±¼äµã»º´æ
MSGTIME g_msgTime1[MAX_MSG_TIME_CALC_COUNT] = {0};       ///< È«¾Ö±¨ÎÄÊ±¼äµã»º´æ

static uint8_t g_fSmvSwap = 0;                           ///< ¼ÆËãSMVµÄÆ¹ÅÒ±êÊ¶
static uint8_t g_fDispSwap = 0;                          ///< ¼ÆËã±¨ÎÄÀëÉ¢¶ÈµÄÆ¹ÅÒ±êÊ¶

#ifdef _LOST_POINT_MODE
	uint8_t g_fSmvLostPoint = 0;							///< SMV¶ªµã±êÊ¶
	uint8_t g_fDispLostPoint = 0;							///< ±¨ÎÄÀëÉ¢¶È¶ªµã±êÊ¶
#endif

// È«¾Ö²¨ÐÎÉú³É»º³åÇø
Error g_error[8] = {0};
DspInfo g_dspInfo = {0};                                 ///< È«¾ÖDSPÐÅÏ¢

SmvData g_smvRealData = {0};

SMV_GEN_DATA_CALC_RT g_smvGenRT = {0};
float g_pMsgDisp[11] = {0.0f};

SMV_DATA_CALC_RT g_smvCalcRT = {0};

//uint32_t g_smvGenNum;

uint8_t g_tskFlag[8]={0};                                 ///< È«¾ÖÈÎÎñ±êÖ¾

// »Ø´«Êý¾Ý±êÊ¶
enum
{
    RES_CONFIG = 0,
    RES_DSP_INFO,
    RES_SMV_REAL_DATA,
    RES_SMV_GEN_RT,
    RES_MSG_DISP,
    RES_SMV_CALC_RT,
    RES_STOP_READ,
    RES_LAST
};
uint8_t g_resFlag[RES_LAST]={0};                   ///< È«¾Ö½á¹û±êÖ¾
uint32_t g_resLength[RES_LAST]={0};                ///< È«¾Ö½á¹ûÊý¾Ý³¤¶È
// È«¾Ö½á¹ûµÄ»º³åÇøÖ¸Õë
const void *g_resPtr[RES_LAST]={&g_error[0], &g_dspInfo, &g_smvRealData,
                &g_smvGenRT, g_pMsgDisp, &g_smvCalcRT, NULL};

static uint16_t g_nSmvCacheCount = 0;              ///< È«¾Ö²ÉÑùÖµ»º´æ´ÎÊý
static uint16_t g_nTimeCacheCount = 0;             ///< È«¾Ö±¨ÎÄÊ±¼ä»º´æ´ÎÊý



static void InitConfig();
static void InitBuffers();
static void SetConfig();
static void GetDspInfo();
static void ResetSmvCache();
static void ResetTimeCache();

static void SmvHelper();
static void SmvGenHelper();
static void MsgDispHelper();
static void RealSmvHelper();

// µ÷ÊÔ°æ±¾ËùÐè
#ifdef _DEBUG
Void SetReason (int fileId, int lineNo, int failureCode)
{

}
#endif

/// ³õÊ¼»¯DSPÉèÖÃ
void InitConfig()
{
    memset(&g_config, 0, sizeof(Config));
    g_config.nMsgTimeCalcCount = 4680;
    g_config.nASDUCount = 8;
	g_config.nSamplingFreq = 12800;
	g_config.nRatedFreq = 50;    
    
    // ³õÊ¼»¯±¨ÎÄÀëÉ¢¶ÈÓ³ÉähashÊý×é
    dispHashCreate(g_config.nASDUCount);
}

/// ³õÊ¼»¯»º³åÇø
void InitBuffers()
{
    // È«¾Ö»º³åÇøÇå0
    memset(g_resFlag, 0, 8*sizeof(uint8_t));
    g_smvCalcData.nChannelCount=0;
    g_smvCalcData.nSmvPerCircle=0;
    memset(g_smvCalcData.nChannelVCType,0,MAX_SMV_CHANNELS*sizeof(uint8_t));
    memset(g_smvCalcData.fChannelData,0, 
        MAX_SMV_CHANNELS*MAX_SMV_CALC_COUNT*sizeof(float));
    
}


/// ÉèÖÃDSP²ÎÊý
void SetConfig()
{
    Error err;
    Config tmpConfig;
	int32_t nSmvCalcCount = 0;
    
    // ¿½±´ÉèÖÃ
    memcpy(&tmpConfig, g_recvBuf+sizeof(FrameHead), sizeof(Config));

	nSmvCalcCount = tmpConfig.nSamplingFreq/tmpConfig.nRatedFreq*10;

    err.nErrno = 0;                                 //success
    // Ö»ÔÊÐíÕâ¼¸ÖÖ¹Ì¶¨´óÐ¡µÄ²ÉÑùµã¼ÆËã£¬¸ù¾Ý²»Í¬µÄ²ÉÑùÆµÂÊµÃÀ´
    switch(nSmvCalcCount)
    {
        case 800:
        case 1000:
        case 1600:
        case 2000:
        case 2560: err.nErrno = 0; break;
        default: err.nErrno = 1; break;
    }

    if(tmpConfig.nMsgTimeCalcCount > MAX_MSG_TIME_CALC_COUNT)
    {
        err.nErrno = 2;
    }

    if(dispHashCreate(tmpConfig.nASDUCount) != 0 )
    {
        err.nErrno = 3;
    }
    
    // Ã»ÓÐ´íÎó¾Í¿½±´²ÎÊýÉèÖÃ
    if(err.nErrno == 0)
    {
        memcpy(&g_config, &tmpConfig, sizeof(Config));    
    }

    // ÉèÖÃÊä³ö
    memcpy(&g_error[0], &err, sizeof(Error));

}

/// »ñÈ¡DSPÐÅÏ¢
void GetDspInfo()
{
    // ÉèÖÃDSP°æ±¾ºÅÊä³ö
    g_dspInfo.nVersion = _DSP_VERSION;

}

/// Çå¿ÕSMVÊý¾Ý»º´æ
void ResetSmvCache()
{
    // ²»Çå¿Õ»º³åÇø£¬½öÒÆ¶¯Ö¸Õëµ½¿ªÍ·
    g_nSmvCacheCount = 0;
    
    // Çå¿ÕÊµ¼ÊÖµ»º³åÇøÊý¾Ý
	// Êµ¼ÊÖµ²»»Ø´«
    g_resFlag[RES_SMV_REAL_DATA] = 0;
    g_resLength[RES_SMV_REAL_DATA] = sizeof(g_smvRealData);
    memset(&g_smvRealData, 0, g_resLength[RES_SMV_REAL_DATA]);

    // Çå¿ÕÐ³²¨µÈ¼ÆËã½á¹û»º³åÇøÊý¾Ý
    g_resFlag[RES_SMV_CALC_RT] = DSP2ARM_CONTROLCODE_SMV_CALC_RT;
    g_resLength[RES_SMV_CALC_RT] = sizeof(g_smvCalcRT);
    memset(&g_smvCalcRT, 0, g_resLength[RES_SMV_CALC_RT]);
}

/// Çå¿Õ±¨ÎÄÊ±¼ä»º´æ
void ResetTimeCache()
{
    g_nTimeCacheCount = 0;
    
	// ÖØÖÃ±¨ÎÄÍ³¼ÆÊý¾Ý
	resetDisp();

    // Çå¿Õ±¨ÎÄÀëÉ¢¶È½á¹û»º´æ
    g_resFlag[RES_MSG_DISP] = DSP2ARM_CONTROLCODE_MSG_DISP_RT;
    g_resLength[RES_MSG_DISP] = sizeof(g_pMsgDisp[0])*11;
    memset(g_pMsgDisp, 0, g_resLength[RES_MSG_DISP]);
}

/// ²¨ÐÎÉú³É
void SmvGenHelper()
{
    SmvGenData smvGenData;
    
    memcpy(&smvGenData, g_recvBuf+sizeof(FrameHead), sizeof(SmvGenData));
    
    SmvGenCalc(&smvGenData, &g_smvGenRT);
	
}

/// ±¨ÎÄÀëÉ¢¶È¼ÆËã
void MsgDispHelper()
{
    MsgTimeData msgTimeData;
	uint8_t fFirstCalc = 1;
    memcpy(&msgTimeData, g_recvBuf+sizeof(FrameHead), sizeof(MsgTimeData));

	// Æ¹ÅÒ²Ù×÷£¬¸´ÖÆÊý¾Ýµ½»º´æ
	if(g_fDispSwap == 0)
	{
	    memcpy(&g_msgTime[g_nTimeCacheCount], msgTimeData.msgTimes, 
	        msgTimeData.nMsgTimeCount*sizeof(MSGTIME));
	}
	else
	{
	    memcpy(&g_msgTime1[g_nTimeCacheCount], msgTimeData.msgTimes, 
	        msgTimeData.nMsgTimeCount*sizeof(MSGTIME));
	}
    g_nTimeCacheCount = g_nTimeCacheCount + msgTimeData.nMsgTimeCount;

    // ´ïµ½¼ÆËã±¨ÎÄÀëÉ¢¶ÈÌõ¼þ
    if(g_nTimeCacheCount >= g_config.nMsgTimeCalcCount)
    {
		// Ê×´ÎÔËÐÐÎÞÐèµÈ´ý¼ÆËãÍê³É
		if(fFirstCalc)
		{
			fFirstCalc = 0;
		}
		else
		{
#if 1
#ifdef _LOST_POINT_MODE
			// ¿ªÆô¶ªµã
			g_fDispLostPoint = 1;
			// ÊÍ·Å½ÓÊÕÐÅºÅÁ¿
			SEM_post(&SEM7);
#endif
#endif
			// µÈ´ý¼ÆËãÍê³É
			SEM_pend(&SEM6, SYS_FOREVER);
		}

		if(g_fDispSwap == 0)
		{
			g_fDispSwap = 1;
#if 1
#ifdef _LOST_POINT_MODE
			// ¹Ø±Õ¶ªµã
			g_fDispLostPoint = 0;
#endif
#endif
			// ÊÍ·Å½ÓÊÕÐÅºÅÁ¿
			SEM_post(&SEM7);


			MsgDispCalc(g_msgTime, &g_config, g_pMsgDisp);
			// Ö¸Ê¾¼ÆËãÍê³É
			SEM_post(&SEM6);
		}
      	else
		{
			g_fDispSwap = 0;
#if 1
#ifdef _LOST_POINT_MODE
			// ¹Ø±Õ¶ªµã
			g_fDispLostPoint = 0;
#endif
#endif
			// ÊÍ·Å½ÓÊÕÐÅºÅÁ¿
			SEM_post(&SEM7);

			MsgDispCalc(g_msgTime1, &g_config, g_pMsgDisp);	
			// Ö¸Ê¾¼ÆËãÍê³É
			SEM_post(&SEM6);
		}

        g_nTimeCacheCount = 0;
		g_resFlag[RES_MSG_DISP] = DSP2ARM_CONTROLCODE_MSG_DISP_RT;
        g_resLength[RES_MSG_DISP] = 11*sizeof(float);
        SEM_post(&SEM0);
    }
	else
	{
		SEM_post(&SEM7);
	}
}
/// Êµ¼ÊÖµ¼ÆËã
void RealSmvHelper()
{
    uint16_t i = 0;
    SmvData smvData;
	int32_t nSmvCalcCount = g_config.nSamplingFreq / g_config.nRatedFreq * 10;
	static uint8_t fFirstCalc = 1;

    // »ñµÃÔ­¼²ÉÑùÖµÊý¾Ý
    memcpy(&smvData, g_recvBuf+sizeof(FrameHead), sizeof(SmvData));
    
    // ·ÀÖ¹»º³åÇøÒç³ö
    if(smvData.nChannelCount > MAX_SMV_CHANNELS)
    {
        smvData.nChannelCount = MAX_SMV_CHANNELS;
    }
    if(smvData.nSmvPerCircle > MAX_SMV_PER_CIRCLE)
    {
        smvData.nSmvPerCircle = MAX_SMV_PER_CIRCLE;
    }
    
    RealSmvCalc(&smvData, &g_smvRealData);
    	

    if(g_nSmvCacheCount + smvData.nSmvPerCircle <= MAX_SMV_CALC_COUNT)
    { 
        for(i=0; i<smvData.nChannelCount; i++)
        {
			if(g_fSmvSwap == 0)
			{
	            memcpy(&g_smvCalcData.fChannelData[i][g_nSmvCacheCount], 
	                    g_smvRealData.fChannelData[i], 
	                    smvData.nSmvPerCircle*sizeof(float));
			}
			else
			{
	            memcpy(&g_smvCalcData1.fChannelData[i][g_nSmvCacheCount], 
	                    g_smvRealData.fChannelData[i], 
	                    smvData.nSmvPerCircle*sizeof(float));			   
			}
        }
    }
    else
    {
        // ¸ù¾Ý±ÈÀýÒò×Ó¼ÆËãÊµ¼ÊÖµ
        for(i=0; i<smvData.nChannelCount; i++)
        {
            // Æ¹ÅÒ²Ù×÷£¬¸´ÖÆ´ÓÉÏ´Î»º´æµãµ½»º³åÇøÄ©Î²µÄÊý¾Ý
			if(g_fSmvSwap == 0)
			{
	            memcpy(&g_smvCalcData.fChannelData[i][g_nSmvCacheCount],
	                    g_smvRealData.fChannelData[i], 
	                    (MAX_SMV_CALC_COUNT-g_nSmvCacheCount)*sizeof(float));
	        }
	        else
	        {
	            memcpy(&g_smvCalcData1.fChannelData[i][g_nSmvCacheCount],
	                    g_smvRealData.fChannelData[i], 
	                    (MAX_SMV_CALC_COUNT-g_nSmvCacheCount)*sizeof(float));
	        }   
        }
    }
    
    // »º´æ´ÎÊý+=Ã¿Í¨µÀÊý¾ÝÊýÁ¿
    g_nSmvCacheCount = g_nSmvCacheCount + smvData.nSmvPerCircle;

    // ÔÝÊ±²»»Ø´«Êµ¼ÊÖµ¼ÆËã½á¹û
    /*g_resFlag[RES_SMV_REAL_DATA] = DSP2ARM_CONTROLCODE_SMV_DATA;
    g_resLength[RES_SMV_REAL_DATA] = sizeof(SmvData);
    SEM_post(&SEM0);*/
	
    // Èç¹û»º´æ´ÎÊý´ïµ½¼ÆËãÐ³²¨µÈËùÐè´ÎÊýÔò¼ÆËãÐ³²¨µÈÊý¾Ý
    if(g_nSmvCacheCount >= nSmvCalcCount)
    {
		// Æ¹ÅÒ²Ù×÷£¬¸´ÖÆÊý¾Ý
		if(g_fSmvSwap == 0)
		{
	        g_smvCalcData.nChannelCount = smvData.nChannelCount;
	        g_smvCalcData.nSmvPerCircle = smvData.nSmvPerCircle;
	        memcpy(g_smvCalcData.nChannelVCType, smvData.nChannelVCType, 
	            smvData.nChannelCount*sizeof(smvData.nChannelVCType[0]));
		}
		else
		{
	        g_smvCalcData1.nChannelCount = smvData.nChannelCount;
	        g_smvCalcData1.nSmvPerCircle = smvData.nSmvPerCircle;
	        memcpy(g_smvCalcData1.nChannelVCType, smvData.nChannelVCType, 
	            smvData.nChannelCount*sizeof(smvData.nChannelVCType[0]));
		}

		// Èç¹ûÊÇÊ×´Î¼ÆËã£¬²»µÈ´ý¼ÆËãÍê³É
		if(fFirstCalc)
		{
			fFirstCalc = 0;
		}
		else
		{

#ifdef _LOST_POINT_MODE
			// ¿ªÆô¶ªµã
			g_fSmvLostPoint = 1;
			SEM_post(&SEM7);
#endif			
			// µÈ´ý¼ÆËãÍê³É
			SEM_pend(&SEM5, SYS_FOREVER);						
		}

        g_nSmvCacheCount = 0;

		// ½øÐÐÐ³²¨¼ÆËã
		SEM_post(&SEM2);
    }
	else
	{
		// ÊÍ·Å½ÓÊÕÐÅºÅÁ¿
		SEM_post(&SEM7);
	}
}
   
/// Ð³²¨¡¢ÓÐÐ§Öµ¡¢¹¦ÂÊ¼ÆËã
void SmvHelper()
{
#if _SMV_TIME_TEST
	Uint32 useTime1 = 0, useTime2 = 0;
    int old;
	old = HWI_disable();
    useTime1 = CLK_gethtime();
#endif
	// Æ¹ÅÒ²Ù×÷£¬ÒÔÖ¸¶¨»º³åÇø×÷ÎªÊäÈë
	if(g_fSmvSwap == 0)
	{
		g_fSmvSwap = 1;
#ifdef _LOST_POINT_MODE
		// ¹Ø±Õ¶ªµã
		g_fSmvLostPoint = 0;
#endif	
		// ÊÍ·Å½ÓÊÕÐÅºÅÁ¿
		SEM_post(&SEM7);

    	SmvDataCalc(&g_smvCalcData, &g_config, &g_smvCalcRT);		
	}
	else
	{
		g_fSmvSwap = 0;
#ifdef _LOST_POINT_MODE
		// ¹Ø±Õ¶ªµã
		g_fSmvLostPoint = 0;
#endif	
		// ÊÍ·Å½ÓÊÕÐÅºÅÁ¿
		SEM_post(&SEM7);

    	SmvDataCalc(&g_smvCalcData1, &g_config, &g_smvCalcRT);		
	}
	// ÊÍ·Å¼ÆËãÍê³ÉÐÅºÅÁ¿
	SEM_post(&SEM5);

#if _SMV_TIME_TEST
    HWI_restore( old );
    useTime2 = CLK_gethtime(); 
	g_smvCalcRT.fRmsValue[0] = (useTime2 - useTime1) * CLK_cpuCyclesPerHtime() / GBL_getFrequency();
#endif
}
/*********************************************************************************************************
** Function name:           main
** Descriptions:            Ö÷º¯Êý£¬³õÊ¼»¯±äÁ¿¡¢´´½¨dsplinkÍ¨µÀ
** Input:                   ÎÞ
** Output:                  ÎÞ
** Note:
*********************************************************************************************************/
Void main()
{
    Int UresSize;

    //TSK_Handle tskLoopTask;
    Int status = SYS_OK;
    // Initialize DSP/BIOS LINK.
    DSPLINK_init () ;
    numTransfers = 1;

    // Initialize variable
    UresSize = ARM_DSP_BUF_SIZE; // user define, same to arm
    xferBufSize = DSPLINK_ALIGN ((UresSize / DSP_MAUSIZE),DSPLINK_BUF_ALIGN);
    
    InitConfig();
    InitBuffers();
    
    status = TSKDSP_create (&info,&g_sendBuf);
    if (status != SYS_OK)
    {
        SET_FAILURE_REASON(status);
    }

    return;
}
/*********************************************************************************************************
** Function name:           tskRecevieFun
** Descriptions:            ½ÓÊÕARM¶Ë·¢ËÍÊý¾ÝÈÎÎñ
** Input:                   ÎÞ
** Output:                  ÎÞ
** Note:                    TSKDSP_execute_ReceiveÔÚÃ»ÓÐ½ÓÊÕµ½Êý¾ÝÊ±´¦ÓÚ×èÈû×´Ì¬
*********************************************************************************************************/
void tskRecevieFun()
{
    Int status = SYS_OK; 
    FrameHead *ch;
    while(1)
    {
        status = TSKDSP_execute_Receive(info,&g_recvBuf);   // ÊÕARM¶ËµÄ
        if (status != SYS_OK){
            SET_FAILURE_REASON(status);
        }
    
		// ÖØÖÃCPU»º´æ
		HAL_cacheInv ((Ptr) g_recvBuf, ARM_DSP_BUF_SIZE) ;

        // ½ÓÊÕµ½µÄÊý¾ÝÔÚ*g_recvBufÖÐ
        ch = (FrameHead *)g_recvBuf;

        // ¸ù¾Ý²»Í¬µÄÃüÁîÂëÖ´ÐÐ²»Í¬µÄ²Ù×÷
        switch (ch->nCommandID)
        {
            case ARM2DSP_CONTROLCODE_CONFIG:
            {
                SetConfig();
                g_resFlag[RES_CONFIG] = DSP2ARM_CONTROLCODE_ERROR;
                g_resLength[RES_CONFIG] = sizeof(Error);
				SEM_post(&SEM7);
                SEM_post(&SEM0);
            }
            break;
            case ARM2DSP_CONTROLCODE_SMV_DATA:
            {
#ifdef _LOST_POINT_MODE
				// Èç¹û¶ªµã±êÊ¶¿ªÆô£¬ÔòÖ±½Ó¶ªÆú
				if(g_fSmvLostPoint)
				{
					continue;
				}
#endif
                g_tskFlag[1] = ARM2DSP_CONTROLCODE_SMV_DATA;
                SEM_post(&SEM1);
            }
            break;
            case ARM2DSP_CONTROLCODE_RESET_SMV:
            {
                ResetSmvCache();
				SEM_post(&SEM7);
                SEM_post(&SEM0);
            }
			break;
            case ARM2DSP_CONTROLCODE_RESET_TIME:
            {
                ResetTimeCache();
				SEM_post(&SEM7);
                SEM_post(&SEM0);
            }
            break;
            case ARM2DSP_CONTROLCODE_SMV_GEN:
            {
                g_tskFlag[1] = ARM2DSP_CONTROLCODE_SMV_GEN;
                SEM_post(&SEM1);
            }
            break;
            case ARM2DSP_CONTROLCODE_TIME_DATA:
            {
#ifdef _LOST_POINT_MODE
				// Èç¹û¶ªµãÄ£Ê½¿ªÆô£¬ÔòÖ±½Ó¶ªÆú
				if(g_fDispLostPoint)
				{
					continue;
				}
#endif
                g_tskFlag[1] = ARM2DSP_CONTROLCODE_TIME_DATA;
                SEM_post(&SEM1);
            }
            break;
            case ARM2DSP_CONTROLCODE_INFO:
            {
                GetDspInfo();
                g_resFlag[RES_DSP_INFO] = DSP2ARM_CONTROLCODE_INFO;
                g_resLength[RES_DSP_INFO] = sizeof(DspInfo);
				SEM_post(&SEM7);
                SEM_post(&SEM0);
            }
            break;
            case ARM2DSP_CONTROLCODE_QUIT:
            {
                TSKDSP_delete(info);
            }
            break;
            case ARM2DSP_CONTROLCODE_STOP_READ:
            {
                g_resFlag[RES_STOP_READ] = DSP2ARM_CONTROLCODE_STOP_READ;
                g_resLength[RES_STOP_READ] = 0;
				SEM_post(&SEM7);
                SEM_post(&SEM0);
            }
            break;
        }
		SEM_pend(&SEM7, SYS_FOREVER);
        //SEM_post(&SEM1);
    }
}

/*********************************************************************************************************
** Function name:           tskSendFun
** Descriptions:            DSP¶Ë·¢ËÍÊý¾ÝÈÎÎñ£¬·¢ËÍÔËËã½á¹ûµ½ARN¶Ë
** Input:                   ÎÞ
** Output:                  ÎÞ
** Note:                    Ìî³äÒª·¢ËÍµÄÊý¾Ýg_sendBuf[SIZE]ÖÐ£¬µ÷ÓÃTSKDSP_execute_Sendº¯Êý¼´¿ÉÍê³É·¢ËÍÊý¾Ý
*********************************************************************************************************/
void tskSendFun()
{
    Int status = SYS_OK;
    FrameHead *sh = (FrameHead *)g_sendBuf;
    Int i=0;
    while(1)
    {
        SEM_pend(&SEM0, SYS_FOREVER);
       
        // ¿½±´Êý¾Ýµ½g_sendBufÖÐ
        for(i=0; i<RES_LAST; i++)
        {
            if(g_resFlag[i] != 0 && g_resLength[i] != 0)
            {
                sh->nCommandID = g_resFlag[i];
                sh->nDataLength = g_resLength[i];   
                memcpy(g_sendBuf+sizeof(FrameHead), g_resPtr[i], g_resLength[i]);           
                g_resFlag[i] = 0;
                g_resLength[i] = 0;
                break;
            }
            else if(g_resFlag[i] != 0 && g_resLength[i] == 0)
            {
                sh->nCommandID = g_resFlag[i];
                sh->nDataLength = g_resLength[i];
                g_resFlag[i] = 0;
                break;
            }
        }

		// ³åÏ´CPU»º´æ
		HAL_cacheWbInv ((Ptr)g_sendBuf, ARM_DSP_BUF_SIZE);

        status = TSKDSP_execute_Send(info);
        if (status != SYS_OK){
                SET_FAILURE_REASON(status);
            }

    }    
}

/*********************************************************************************************************
** Function name:           tskCalc40msFun
** Descriptions:            40ms¼ÆËãÈÎÎñ
** Input:                   ÎÞ
** Output:                  ÎÞ
** Note:                    ¼ÆËã²¨ÐÎÉú³É£¬±¨ÎÄÀëÉ¢¶ÈºÍSMVÊµ¼ÊÖµ
*********************************************************************************************************/
void tskCalc40msFun()
{
    while(1)
    {

        SEM_pend(&SEM1, SYS_FOREVER);
    
        /*
         * ¼ÆËã³ÌÐò
         */
         switch(g_tskFlag[1])
         {
            case ARM2DSP_CONTROLCODE_SMV_GEN:
            {
                SmvGenHelper();
                g_resFlag[RES_SMV_GEN_RT] = DSP2ARM_CONTROLCODE_SMV_GEN_RT;
                g_resLength[RES_SMV_GEN_RT] = sizeof(SMV_GEN_DATA_CALC_RT);
				SEM_post(&SEM7);
                SEM_post(&SEM0);
            }
            break;
            case ARM2DSP_CONTROLCODE_TIME_DATA:
            {
                MsgDispHelper();
            }
            break;
            case ARM2DSP_CONTROLCODE_SMV_DATA:
            {
                RealSmvHelper();
                /*g_resFlag[RES_SMV_REAL_DATA] = DSP2ARM_CONTROLCODE_SMV_DATA;
                g_resLength[RES_SMV_REAL_DATA] = sizeof(SmvData);
                SEM_post(&SEM0);*/
            }
            break;
         }
         //SEM_post(&SEM0);          //  tskSendFun

    }           
}

/*********************************************************************************************************
** Function name:           tskCalc200msFun
** Descriptions:            200ms¼ÆËãÈÎÎñ
** Input:                   ÎÞ
** Output:                  ÎÞ
** Note:                    ¼ÆËãÐ³²¨¡¢¼äÐ³²¨¡¢¸ß´ÎÐ³²¨¡¢ÐòÁ¿
*********************************************************************************************************/
void tskCalc200msFun()
{

    while(1)
    {
        SEM_pend(&SEM2, SYS_FOREVER);
        /** ¼ÆËã³ÌÐò*/
        SmvHelper();
        g_resFlag[RES_SMV_CALC_RT] = DSP2ARM_CONTROLCODE_SMV_CALC_RT;
        g_resLength[RES_SMV_CALC_RT] = sizeof(SMV_DATA_CALC_RT);
        SEM_post(&SEM0);
    }
}

/*********************************************************************************************************
** Function name:           tskCalc5120msFun
** Descriptions:            5120ms¼ÆËãÈÎÎñ
** Input:                   ÎÞ
** Output:                  ÎÞ
** Note:                    5.12sË²Ê±ÉÁ±äÖµ¼ÆËã
*********************************************************************************************************/
void tskCalc5120msFun()
{
    while(1)
    {
        SEM_pend(&SEM3, SYS_FOREVER);
    }
}  
/*********************************************************************************************************
** Function name:           tskCalc10minFun
** Descriptions:            10min¼ÆËãÈÎÎñ
** Input:                   ÎÞ
** Output:                  ÎÞ
** Note:                    10min¶ÌÉÁ±äÖµ¼ÆËã£¬ÀÛ¼Æ12´Î¼ÆËã³ö³¤ÉÁ±äÖµ
*********************************************************************************************************/
void tskCalc10minFun()
{
    while(1)
    {
        SEM_pend(&SEM4, SYS_FOREVER);

    }
}
